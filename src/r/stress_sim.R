f.stress.sim <- function(chart,
                         f.spike,
                         f.decay,
                         df.mapping,
                         stress.init = 0.0){
  #' Simulates the Stress through types
  #' 
  #' @description 
  #' 
  #' @param chart Chart generated by `f.stress.mapper`
  #' @param f.spike A **Function** to dictate how stress
  #' should change upon encountering different types
  #' 
  #' The function **must** have 'stress' and 'args'
  #' arguments.
  #' The function **must** return the new 'stress' value
  #' 
  #' Note: Arguments used in the function should be
  #' the exact same name as the ones used in stress
  #' mapper
  #' 
  #' @param f.decay A **Function** to dictate how stress
  #' should change during idle.
  #' 
  #' The function must have both 'stress' and 
  #' 'duration' arguments.
  #' The function must return the new 'stress' value
  #' 
  #' Note: 'duration' is measured in **ms**. There are no
  #' custom arguments.
  #' 
  #' @param df.mapping A 'mapping' **data.frame** to 
  #' indicate what constants to use for `f.spike`.
  #' 
  #' The table must contain the column 'types', with
  #' rows: 'note', 'lnoteh', 'lnotel'.
  #' This can be used as the base template
  #' `data.frame(types = c("note", "lnoteh", "lnotel"))`
  #'
  #' Note: Extra column names must be named exactly
  #' the same as arguments in `f.spike`
  #' 
  #' @param stress.init The **numeric** of 'stress' to 
  #' initialize the simulation with
  #' 
  #' 
   
  require(magrittr)
  require(dplyr)
  
  # Firstly, we join the mapping with the chart
  chart %<>% merge(df.mapping, by='types')
  
  # These are the column indexes of the custom arguments
  args.columns = 4:(ncol(chart))
  
  # Allocate columns in advance
  chart$stress.spike <- NA
  chart$stress.decay <- NA
  
  chart <- chart[order(chart$offsets, decreasing = F),]
  
  "Chart Frame is used to fill in those missing values 
  generated by columns on different offsets.
  
  This is used to do a OUTER JOIN to each key groups,
  hence you get NA data on those rows that shouldn't
  have data."
  chart.frame <- data.frame(offsets=unique(chart$offsets))
  
  # We will be looping through the chart by key
  chart.k.split <- split(x = chart, f = chart$keys)
  chart.k.list <- c()
  for (key in 1:length(chart.k.split)){
    stress = 0
    offset.old = 0
    
    chart.k <- chart.k.split[[key]]
    chart.k <- merge(chart.k, chart.frame, by='offsets', all=T)
    chart.k$keys <- key
    for (row in 1:nrow(chart.k)) {
      
      "is.na check here is to check for the original notes,
      excluding those added by Chart Frame's OUTER JOIN"
      if (!is.na(chart.k[row, "types"])){
        # This extracts all user defined columns as a list
        args <- as.list(chart.k[row, args.columns])
        
        # Current offset
        offset.new <- as.numeric(chart.k[row, "offsets"])
        
        # Calculate decay then assign to dataframe
        stress <- f.decay(stress = stress,
                          duration = offset.new - offset.old)
        stress <- max(stress, 0) # Stress will not go below 0
        chart.k[row, "stress.decay"] <- stress
        
        # Calculate spike then assign to dataframe
        stress <- f.spike(stress = stress,
                          args = args)
        chart.k[row, "stress.spike"] <- stress
        
        # Update new offset
        offset.old <- chart.k[row, "offsets"]
      } else {
        # Current offset
        offset.new <- as.numeric(chart.k[row, "offsets"])
        
        # Calculate decay then assign to dataframe
        
        "Note that we assign to stress.x because we don't want
        to have cumulative decay if the formula provided 
        happens to be one."
        stress.x <- f.decay(stress = stress,
                            duration = offset.new - offset.old)
        stress.x <- max(stress.x, 0) # Stress will not go below 0
        chart.k[row, "stress.decay"] <- stress.x
      }
    }
    
    chart.k.list <- append(chart.k.list, list(chart.k))
  }
  
  # Join charts of different keys into one
  chart <- bind_rows(chart.k.list)
  chart$stress <- pmax(chart$stress.spike,
                       chart$stress.decay,
                       na.rm = T) 
  return(chart)
}

# Some test data
# chart <- data.frame(keys = c(1,2,3,4),
#                     types = c('note', 'lnoteh', 'lnotel', 'note'),
#                     offsets = c(10,20,30,40))
# 
# df.mapping <- data.frame(types = c('note', 'lnoteh', 'lnotel'),
#                          adds = c(50,50,25),
#                          mults = c(1.1, 1.1, 1.03))
# 
# 
# f.spike <- function(stress, args){
#   return((stress + args$adds) * args$mults)
# }
# f.decay <- function(stress, duration){
#   return(stress / (2 ** duration))
# }
