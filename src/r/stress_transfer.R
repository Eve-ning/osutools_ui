f.stress.tf <- function(chart,
                        tf.group,
                        func){
  #' Transfers stress to other keys
  #' 
  #' @description Depending on the function provided,
  #' stress transfer may vary. However, in most cases
  #' these stress transfers are assumptions on playstyle
  #' 
  #' This will not overwrite the current stress columns,
  #' it will generate a separate one.
  #' 
  #' @param chart The **data.frame** generated by f.chart.sim
  #' @param tf.group A **list** of key groups to have internal
  #' stress transfer. There's a specific format to use.
  #' @param func A **function** to use on the group. Refer to
  #' examples for specifications.
  #' 
  #' @examples 
  #' The function also has a specific format
  #' `function(stress.main, stress.others){ return(stress.main) }`
  #' `stress.main` is the current key's stress value
  #' `stress.others` is the other key's stress values in a vector.
  #' 
  #' The function must return the stress value.
  #'  
  
  require(magrittr)
  require(reshape2)
  require(Rfast)
  
  chart <- chart.sim %>%
    dcast(offsets ~ keys, value.var = 'types')
  
  
  
  
  # chart <- chart.sim
  # chart <- chart[!is.na(chart$types),]
  # chart.k.split <- split(chart, chart$keys)
  # 
  # for(row in 1:nrow(chart)){
  #   row.offset <- chart[row,'offsets']
  #   row.key <- chart[row, 'keys']
  #   
  #   chart.next.l = list()
  #   
  #   for(k in length(chart.k.split)){ # Find next
  #     chart.k <- chart.k.split[[k]]
  #     chart.knth(abs(chart.k$offsets - row.offset),k = 2,index.return = T)
  #   }
  # }
  
}
