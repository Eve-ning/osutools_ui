f.diff.broadcast <- function(chart,
                             ignore.types = c('lnotel')){
  #' For each row, gets the time before the next key
  #' 
  #' This will not overwrite the current columns,
  #' it will generate a separate one.
  #' 
  #' @param chart The **data.frame** generated by f.chart.parse
  #' @param ignore.lnotel A **logical** to determine if lnotel
  #' should be included in the broadcasting
  
  require(magrittr)
  require(reshape2)
  require(Rfast)
  require(dplyr)
  
  Rcpp::sourceCpp("src/cpp/diff_broadcast.cpp")
  
  # Drop NA rows
  chart.bcst <- chart %>%
  
  # Ignores any types that matches the list
    filter(!(types %in% ignore.types)) %>%
    
    # As per the cpp function's requirements, the types
    # that we would want to participate is TRUE, while
    # the spectators are FALSE
    mutate(types = T) %>% 
  
  # Cast keys to longer table.
    dcast(offsets ~ keys, value.var = 'types', fill = F) %>% 
  
  # The plan is to flip the chart up-side down, then 
  # we track different columns on the accumulated
  # offsets. 
    arrange(desc(offsets))
    
  keys <- ncol(chart.bcst) - 1
  
  # Broadcast with cpp and assign back to the [2:] columns
  chart.bcst[,2:ncol(chart.bcst)] <-
    cpp_broadcast(chart.bcst$offsets,
                  as.matrix(chart.bcst[,2:ncol(chart.bcst)]))

  chart.bcst %<>%
    # Merge to get back original type data
    merge(chart, by = 'offsets') %>% 
    
    # Melt bcst columns to diffs
    melt(measure.vars = 2:(keys+1),
         variable.name = 'keys.tos',
         value.name = 'diffs',
         na.rm = T) %>%
    
    # Rename for clarity
    rename(keys.froms = keys) %>%
    
    # Coerce to numeric
    mutate(keys.tos = as.numeric(keys.tos)) %>%
    
    # Remove invalid diffs
    filter(diffs > 0)
  
  return(chart.bcst)
}
