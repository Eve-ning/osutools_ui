f.diff.broadcast <- function(chart,
                             ignore.lnotel = T){
  #' For each row, gets the time before the next key
  #' 
  #' This will not overwrite the current columns,
  #' it will generate a separate one.
  #' 
  #' @param chart The **data.frame** generated by f.chart.sim
  #' @param ignore.lnotel A **logical** to determine if lnotel
  #' should be included in the broadcasting
  
  require(magrittr)
  require(reshape2)
  require(Rfast)
  
  # This logical is a temporary code, we may change
  # ignore.lnotel to be more modifiable.
  if (ignore.lnotel){
    chart$types[chart$types == 'lnotel'] <- NA
  }
  
  # Cast keys to longer table.
  chart %<>% 
    dcast(offsets ~ keys, value.var = 'types')
  
  # The plan is to flip the chart up-side down, then 
  # we track different columns on the accumulated
  # offsets.
  chart <- chart[order(chart$offsets,decreasing = T),]

  # Grabs the number of keys in the chart
  keys <- ncol(chart) - 1
  
  # Diff trackers are variable that tracks all columns
  diff.trackers <- vector(mode = "numeric",
                          length = keys)
  
  # Append extra columns
  diff.columns <- data.frame(matrix(ncol=keys))
  diff.columns %<>% rename_all(paste0, ".diff")
  chart %<>% cbind(diff.columns)
  
  # This is the column to reference from
  col <- 2 
  offset.old <- 0
  for (row in 1:nrow(chart)){ 
    # Grab current row offset
    offset <- chart[row, 'offsets']
    
    diff.offset <- offset.old - offset
    diff.trackers <- diff.trackers + diff.offset
    
    # Assign current diffs
    chart[row, (col+keys):(col+2*keys-1)] <- diff.trackers
    
    # Reset Mask is to reset the difference once a note is
    # encountered
    reset.mask <- apply(chart[row, col:(col+keys-1)],
                        2,
                        FUN=is.na)
    diff.trackers[!reset.mask] <- 0
    
    # Assign old offset
    offset.old <- offset
  }
}
