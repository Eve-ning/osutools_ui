---
title: "documentation"
author: "eve-ning"
date: "5/10/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
library(knitr)
library(magrittr)
```

# Introduction

Keep it short, make a simulator that plays VSRG

# THE PLAN

1. Create an interface for **VSRG Charts**
2. Create an interface for the **Player**
3. Create an environment where both of those **interact**

  We want to be able to test out the parameters

4. Simulate the plays and train the machine according to players

# Goal

We want to be able to simulate virtual player's playthroughs regardless of if it's accurate.
Making it accurate to reality would be the next goal.

Our expected output would be something like:

```{r echo=F}
ex.offsets = c(1,2,2,3,4)
ex.keys = c(0,1,2,0,0)
ex.acc = c(0.9,0.3,0.4,0.7,0.1)

ex = cbind(offsets = ex.offsets, keys = ex.keys, 'predicted accuracy' = ex.acc)

kable(ex,caption = "Expected output")
rm(ex.offsets, ex.keys, ex.acc, ex)
```

# Accuracy or Deviation

Let's say the player hits the note, **50ms early**, how do we translate that into accuracy? 

We will have to map it to a function, which "grades" the deviation, similar to VSRG Judgements.

**However**, this deviation holds more meaning than a mapped deviation, as there is no *universal function* to translate deviation into accuracy. Hence, we will focus on deviation instead of accuracy.

## Defining Deviation

When we ask players on what makes them hit a note accurately, it usually narrows down to the most common answers:

- Player skill
- Map difficulty

We need to understand that **Player skill** is totally independent of **Map difficulty**. Hence we must enforce that:

**Map difficulty should not be dynamically calculated from player performance**

# Process
I have created a draft simulation, let's run through how it works
```{r echo=F}
# Libraries Required
library(reticulate)
library(ggplot2)
library(magrittr)
library(dplyr)

# os needs to be on the correct directory to do source_python
os <- import('os')
os$chdir('../py/')

# Load required python files
source_python("chart_parser.py")
source_python("stress_mapper.py")
source_python("stress_sim.py")
source_python("stress_model.py")
```

## Chart Input
This is where the user imports their map. Here are some samples I used

```{r}
osu.hypnotize <- "../osu/Camellia VS. lapix - Hypnotize (Evening) [bool worldwpdrive(const Entity &user);].osu"
osu.stargazer <- "../osu/stargazer - dreamer (Evening) [wander].osu"
osu.maniera <- "../osu/D(ABE3) - MANIERA (iJinjin) [Masterpiece].osu"
```

## Chart Parser
As to make it accessible for all users, we need to parse the most common types of maps
```{r}
# Read the map into a DataFrame
chart <- ChartParser(osu.maniera)
chart <- chart$parse_auto()

kable(head(chart, 10), caption = 'Example Parsed Chart')
```

## Stress Mapper
Stress Mapper joins maps created by the user to the parsed map.

### Stress Maps
Stress Maps are user-defined parameter maps for the spike function later.

```{r}
# Create StressMapping with a DataFrame
sm_df = data.frame(types = c('note','lnoteh','lnotet'),
                   adds = c(50, 50, 50),
                   mults = c(1, 1, 1))

smp = StressMapper(sm_df)

# Map over to the chart
chart = smp$map_over(chart)

kable(sm_df, caption="Example Mapping", row.names = F)
kable(head(chart, 10), caption="Example Mapped", row.names = F)
```

## Stress Simulator
Stress Simulator takes the arguments mapped and runs through a simulation of the chart, appending the results by column.

The spike and decay function is defined by the stress model.

### Stress Model
The stress model defines spike and decay function
Assuming all stress starts from **0**, we can somewhat simulate `keys = 0`

```{r}
# Specify Decay and Spike Functions
decay <- function(stress, duration) {
  return(stress / (2 ** (duration / 1000)))
}

spike <- function(stress, adds, mults) {
  return (stress + adds) * mults
}

# Create StressModel
smd = StressModel(decay_func = decay,
                  spike_func = spike,
                  stress = 0.0)

# Integrate into Stress Simulator
ss = StressSim(smd)

# Run the Simulation and assign new dataframe to chart.stress
chart.stress = ss$simulate(chart)
```

```{r}
# Plot out chart
ggplot(chart.stress) +
  aes(x = offsets,
      y = stress) +
  geom_smooth(aes(group = columns, color = factor(columns)),
              se = F)
```
## Stress Transfer
### Stress Hand
#### Transfer Function
### Stress Body
#### Transfer Function
## Stress Pattern


