---
title: "documentation"
author: "eve-ning"
date: "5/10/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
library(magrittr)
```

# Introduction

Keep it short, make a simulator that plays VSRG

# THE PLAN

1. Create an interface for **VSRG Charts**
2. Create an interface for the **Player**
3. Create an environment where both of those **interact**

  We want to be able to test out the parameters

4. Simulate the plays and train the machine according to players

# Goal

We want to be able to simulate virtual player's playthroughs regardless of if it's accurate.
Making it accurate to reality would be the next goal.

Our expected output would be something like:

```{r echo=F}
ex.offsets = c(1,2,2,3,4)
ex.keys = c(0,1,2,0,0)
ex.acc = c(0.9,0.3,0.4,0.7,0.1)

ex = cbind(offsets = ex.offsets, keys = ex.keys, 'predicted accuracy' = ex.acc)

kable(ex,caption = "Expected output")
rm(ex.offsets, ex.keys, ex.acc, ex)
```

# Accuracy or Deviation

Let's say the player hits the note, **50ms early**, how do we translate that into accuracy? 

We will have to map it to a function, which "grades" the deviation, similar to VSRG Judgements.

**However**, this deviation holds more meaning than a mapped deviation, as there is no *universal function* to translate deviation into accuracy. Hence, we will focus on deviation instead of accuracy.

## Defining Deviation

When we ask players on what makes them hit a note accurately, it usually narrows down to the most common answers:

- Player skill
- Map difficulty

We need to understand that **Player skill** is totally independent of **Map difficulty**. Hence we must enforce that:

**Map difficulty should not be dynamically calculated from player performance**

Let's summarize it with a draft formula, granted, it is watered-down.

$$D = p(m(x))$$ 
# Process

- Chart Input
- Chart Parser
- Stress Mapper
  - Stress Maps
- Stress Simulator
  - Stress Model
    - Spike Function
    - Decay Function
- Stress Transfer
  - Stress Hand
    - Transfer Function
  - Stress Body
    - Transfer Function
- Stress Pattern

## Chart Input
This is where the user imports their map.

## Chart Parser
As to make it accessible for all users, we need to parse the most common types of maps
```{r echo=F}
p.parse <- data.frame(offsets = c(1,2,2,3,4),
                      keys = c(0,1,2,0,0),
                      types = c("Note",
                                "Note",
                                "Note",
                                "Long Note Head",
                                "Long Note Tail"))


kable(p.parse, caption = 'Example Parsed Chart')
```

## Stress Mapper
Stress Mapper joins maps created by the user to the parsed map.

### Stress Maps
Stress Maps are user-defined parameter maps for the spike function later.

```{r}
p.mapping <- data.frame('types' = c('Note', 'Long Note Head', 'Long Note Tail'),
                        'adds' = c(1, 2, 3),
                        'mults' = c(1.1, 1.2, 1.3))

kable(p.mapping, caption="Example Mapping")

p.map <- merge(x=p.parse, y=p.mapping, by='types')
p.map <- p.map[order(p.map$offsets),]
p.map

kable(p.map, caption="Example Map", row.names = F)
```

## Stress Simulator
This takes the 
### Stress Model
#### Spike Function
#### Decay Function
## Stress Transfer
### Stress Hand
#### Transfer Function
### Stress Body
#### Transfer Function
## Stress Pattern


