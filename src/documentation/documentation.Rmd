---
title: "documentation"
author: "eve-ning"
date: "5/10/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

Keep it short, make a simulator that plays VSRG

# THE PLAN

1. Create an interface for **VSRG Charts**
2. Create an interface for the **Player**
3. Create an environment where both of those **interact**

  We want to be able to test out the parameters

4. Simulate the plays and train the machine according to players

# Goal

We want to be able to simulate virtual player's playthroughs regardless of if it's accurate.
Making it accurate to reality would be the next goal.

Our expected output would be something like:

```{r echo=F}
library(knitr)
ex.offsets = c(1,2,2,3,4)
ex.keys = c(0,1,2,0,0)
ex.acc = c(0.9,0.3,0.4,0.7,0.1)

ex = cbind(offsets = ex.offsets, keys = ex.keys, 'predicted accuracy' = ex.acc)

kable(ex,caption = "Expected output")
rm(ex.offsets, ex.keys, ex.acc, ex)
```

# Accuracy or Deviation

Let's say the player hits the note, **50ms early**, how do we translate that into accuracy? 

We will have to map it to a function, which "grades" the deviation, similar to VSRG Judgements.

**However**, this deviation holds more meaning than a mapped deviation, as there is no *universal function* to translate deviation into accuracy. Hence, we will focus on deviation instead of accuracy.

## Defining Deviation

When we ask players on what makes them hit a note accurately, it usually narrows down to the most common answers:

- Player skill
- Map difficulty

We need to understand that **Player skill** is totally independent of **Map difficulty**. Hence we must enforce that:

**Map difficulty should not be dynamically calculated from player performance**

Let's summarize it with a draft formula, granted, it is watered-down.

$$D = p(m(x))$$

